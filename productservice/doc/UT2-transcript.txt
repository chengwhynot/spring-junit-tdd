transcript

## TDD Step 2, make it green
很好，我们现在有一个能够作为验收的Happy Path用例，下一步我们需要修改现有代码，使得这个测试通过。
还是要提醒一下，单元测试属于白盒测试范畴，因此我们需要了解代码的实现逻辑和过程。我们先看一下改把这个验证重名的逻辑放到哪里？
先打开Controller，第一个想法是在controller调用save之前，先调用一下service层的findByName方法。如果找到同样名称的，那么返回409。可是再一想，controller层应该重点在解析入参，构造复合契约的返回参数，不应该参与逻辑。
再打开service看一下，可以把同样逻辑放到service的save方法来做。在save之前，先看下有没有重名的，如果有……扔出来一个异常。为了简化，我这里先不搞自定义异常了，就先找一个看起来比较接近的异常，用一下。
I. Controller 修改
1. 先修改接口契约。save方法抛出 InvalidAttributesException
2. 然后我们得修改一下对应的controller，把调用语句挪到try catch中；
最极端的TDD,就是修改最少的代码，刚好让测试通过即可。那这样我们先来修改controller，判断如果是InvalidAttributeException，构造对应的HttpStatus。
OK，controller修改完成，重新运行一下tests，通过了。完成了？！完成了吗？并没有完成实现，但测试通过，说明了什么呢？说明了我们 service 的 save() 方法只要按照设计的扔出那个异常，controller就会同样按照设计，给前端返回接口契约中描述的409。这也是采用TDD后，更为重要的一个想法的改变，比起实现，契约先行。先想好和各个客户方的接口是什么样子的，有什么边界场景，如何返回边界场景。然后再去开发实现类。这样就算修改实现过程，只要没有破坏各个契约，也就说明对原有逻辑的影响几乎没有。

II. Service 修改
OK，Controller 层修改完毕，接下来用同样的道理，修改一下 service 以及 DAO。
这次传统一些，我们先改实现类，然后补充测试用例来覆盖。

在service中添加一个私有方法，检查是否有重名的products，起个名字叫isNameExists(String name)，返回boolean类型。写的粗暴一些，直接findAll，然后循环比较，如果有重名的，直接返回false。
然后原来的 save() 方法判断如果有重名的，抛出异常。

接下来想想如何验证？至少先保证Happy Path通过。我们构造一个Product集合，放入一个名为 Product Name的Product，然后设置 repository 的 findAll() 方法返回这个集合，即返回一个包含 Product Name 的产品列表。 那么我们调用service 的 save() 方法，再次传入这个Product，应该得到一个异常。

OK，Happy path通过，我们再来一条反例。非空的产品列表，传入一个非重名的 Product，执行save() 时，成功，并返回我们设计好的 mockProduct。
继续添加一个用例空列表，添加newProduct，应该成功，并且有version number 应该也是正确的。

写到这里，这个新功能应该就算加进去了，告一段落。我们回顾一下，看看单元测试的特点。
再仔细看一下，单元测试主要是通过 mock 手段，来把被测试类、被测试方法 所依赖的其它方法，都给出了设定的返回值。因此，单元测试有2个很明显的特点：
1. 白盒测试，要写出有意义的单元测试，必须了解被测方法是如何实现的。这样才能 mock 必要的方法。
2. 更多的是 代码行为测试，确保被测方法中的逻辑，是按照预计、设想的实现的。

这样在写单元测试是也有2点：
1. 要关注 SUT 的被测方法，而不是sut 所依赖的层、方法的正确性。
2. 通过构建合适的 断言，来验证被测方法的逻辑确实是按照给定条件执行的。避免写成集成测试。

III. Repository 层

修改 Service的 test方法，同样抛出这类异常。编译一下，ok通过了。
接下来有两个选择，

